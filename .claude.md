# Claude Code Instructions for iot-image

## Project Overview

`iot-image` is a service for generating images suitable for IoT devices with constrained resources. The system consists of two components:
- **Server (Rust)** - Runs on Raspberry Pi Zero 2 W (512 MB RAM, ARM Cortex-A53 CPU), fetches weather data, generates optimized images
- **Client (Arduino/ESP32-S3)** - Runs on Seed Studio reTerminal e1002, downloads and displays images on 7.3" e-ink display

The server downloads weather data from a public API, generates device-optimized images, and serves them via HTTP. The client periodically fetches the latest image and renders it to the e-ink display.

## Developer Workflows

### Rust Server - Build & Run (Local Development)
```bash
cd server
cargo build        # Debug build
cargo build --release  # Optimized build
cargo run -- --lat="$OPEN_WEATHER_LAT" --lon="$OPEN_WEATHER_LON" --open-weather-key="$OPEN_WEATHER_KEY"
```

### Rust Server - Cross-Compilation for Raspberry Pi Zero 2 W
Target: `aarch64-unknown-linux-gnu` (64-bit ARM)

**Setup cross-compilation:**
```bash
rustup target add aarch64-unknown-linux-gnu
cargo install cross  # Use 'cross' crate for easier compilation
```

**Build for RPi:**
```bash
cd server
cross build --release --target aarch64-unknown-linux-gnu
# Binary: target/aarch64-unknown-linux-gnu/release/iot-image-server
```

**Deploy to RPi (via SCP or similar):**
```bash
scp server/target/aarch64-unknown-linux-gnu/release/iot-image-server pidev:~/bin
ssh pidev ~/bin/iot-image-server --lat="37.7749" --lon="-122.4194" --open-weather-key="YOUR_KEY"
```

### Arduino Client - Setup & Build (ESP32-S3 on reTerminal e1002)

**Install Arduino CLI:**
```bash
# macOS
brew install arduino-cli

# Linux
curl -fsSL https://raw.githubusercontent.com/arduino/arduino-cli/master/install.sh | sh
```

**Initialize Arduino CLI and add ESP32 board support:**
```bash
arduino-cli core install esp32:esp32
```

**Build and upload to device:**
```bash
cd client
arduino-cli compile --verbose --fqbn esp32:esp32:esp32s3 .
arduino-cli upload --verbose --fqbn esp32:esp32:esp32s3 --port /dev/cu.wchusbserial110
arduino-cli monitor -p /dev/cu.wchusbserial110 -c baudrate=115200
```

**Monitor serial output:**
```bash
arduino-cli monitor -p /dev/ttyUSB0 -c baudrate=115200
```

## Architecture & Data Flow

1. **Rust Server** fetches weather data from OpenWeatherMap API
2. **Server** generates optimized images (PNG format) suitable for e-ink display
3. **ESP32-S3 Client** periodically downloads images from server via HTTP
4. **Client** renders images on 7.3" e-ink display using GxEPD2 library

## Code Organization

```
iot-image/
├── server/              # Rust backend service
│   ├── src/
│   │   ├── main.rs      # CLI orchestration & weather printing
│   │   └── weather.rs   # OpenWeatherMap API integration
│   └── Cargo.toml
├── client/              # Arduino/ESP32-S3 frontend
│   ├── client.ino       # Main sketch
│   ├── config.h         # WiFi & server configuration
│   └── arduino_secrets.h # WiFi credentials (not committed)
└── .claude.md
```

## Rust Server - Architecture & Patterns

### Code Structure (`server/src/`)
- **`main.rs`** - CLI orchestration, weather data printing
  - Uses `clap` derive macros for argument parsing: `--lat`, `--lon`, `--open-weather-key`
  - Helper functions for weather categorization: `temperature_text()`, `humidity_text()`, `wind_text()`
  - Prints 6-day forecast with temperatures, humidity, wind, sunrise/sunset times

- **`weather.rs`** - OpenWeatherMap API integration
  - Data structures: `WeatherData`, `CurrentWeather`, `DailyWeather`, `TempRange`, `Weather`
  - `fetch_weather()` async function queries OpenWeatherMap 3.0 One Call API
  - Includes all fields: temperature ranges (min/max/morn/day/night), humidity, wind_speed, sunrise/sunset, weather icons

### Dependencies
- `reqwest` (0.11) - HTTP client with JSON support
- `tokio` (1.x) - Async runtime
- `chrono` (0.4.38) - DateTime parsing and formatting
- `clap` (4.4) - CLI argument parsing with derive macros
- `serde` / `serde_json` - JSON serialization for API responses

### Release Optimizations (for RPi)
```toml
[profile.release]
lto = true              # Link-time optimization
strip = true            # Strip debug symbols
opt-level = "z"         # Optimize for size
```

## Arduino Client - Architecture & Patterns

### Hardware Target
- **Device:** Seed Studio reTerminal e1002
- **Processor:** ESP32-S3 (32-bit Xtensa dual-core, 240 MHz)
- **Display:** 7.3-inch full-color e-paper display (GDEP073E01), 800x480 pixels, 8 colors (black, white, red, green, blue, yellow)
- **Connectivity:** WiFi (2.4 GHz 802.11 b/g/n)

### Code Structure (`client/`)
- **`client.ino`** - Main Arduino sketch
  - WiFi connection with SSID/password from `arduino_secrets.h`
  - HTTP client to download PNG image from server into memory
  - PNG decoding using PNGdec library (memory-based, not streaming)
  - Display rendering via GxEPD2 library with custom color mapping
  - Deep sleep mode between updates (saves power)

- **`config.h`** - Configuration constants
  - Server URL/IP and port
  - Update interval (default: 6 hours / 21600 seconds)
  - Display pin assignments for reTerminal e1002
  - SD card and other peripheral pin definitions

- **`arduino_secrets.h`** - Credentials (git-ignored)
  - `SECRET_SSID` - WiFi network name
  - `SECRET_PASS` - WiFi password

### Key Libraries
- **WiFi** - Built-in ESP32 WiFi support
- **HTTPClient** - Built-in HTTP request library
- **GxEPD2** - E-ink display driver (GxEPD2_730c_GDEP073E01 for 7.3" color)

### Important Implementation Details

#### EPBM Bitmap Format
- **Native format for e-ink displays**: Custom EPBM (E-Paper BitMap) format
- **Header:** 8 bytes (magic "EPBM" + width + height as 16-bit big-endian)
- **Pixel data:** 1 byte per pixel (direct color mapping to GxEPD2 palette)
- **File size:** 384,008 bytes for 800×480 display
- **Download:** Entire bitmap loaded into RAM (allocated dynamically)
- **Rendering:** Direct pixel-by-pixel drawing with color lookup
- **Memory:** Freed after rendering completes

#### Color Mapping for E-ink
The `map_epbm_color()` function converts EPBM values to GxEPD2 constants:
- 0 → GxEPD_BLACK
- 1 → GxEPD_WHITE
- 2 → GxEPD_GREEN
- 3 → GxEPD_BLUE
- 4 → GxEPD_RED
- 5 → GxEPD_YELLOW

#### Power Management
- Deep sleep between updates using `esp_deep_sleep_start()`
- WiFi disconnected before sleep to save power
- Update interval: 6 hours (21600 seconds)

### Display Update Pattern
```
1. Connect to WiFi
2. Download entire EPBM bitmap into memory buffer (malloc)
3. Validate EPBM header and dimensions
4. Render pixels directly to display using color lookup
5. Refresh e-ink display (takes ~5-10 seconds)
6. Free bitmap buffer
7. Disconnect WiFi
8. Enter deep sleep for 6 hours
9. Wake and repeat
```

## Integration Points

### Server → Client Communication
- **Server exposes HTTP endpoint** to serve generated bitmap file
  - Endpoint: `/` (configured in `config.h`)
  - Returns binary EPBM data (384,008 bytes)
  - Content-Type: application/octet-stream

- **Client queries endpoint periodically**
  - Request: `GET http://pidev.local:8080/weather/seed-e1002.bin`
  - Downloads into memory buffer (384KB)
  - Timeout: 30 seconds
  - Validates EPBM header before rendering

### Environment & Configuration
- **Server:** Environment variables or CLI args for `OPEN_WEATHER_LAT`, `OPEN_WEATHER_LON`, `OPEN_WEATHER_KEY`
- **Client:**
  - `config.h` for server URL, update interval, pin assignments
  - `arduino_secrets.h` for WiFi credentials (not committed to git)
- Both handle network failures gracefully (timeouts, retries)

## Testing & Validation

### Rust Server
- Build: `cd server && cargo build --release`
- Run locally: `cargo run -- --lat="37.7749" --lon="-122.4194" --open-weather-key="YOUR_KEY"`
- Verify output: Check console for 6-day forecast with temperature categories, humidity, wind

### Arduino Client
- Monitor serial: `arduino-cli monitor -p /dev/cu.wchusbserial110 -c baudrate=115200`
- Expected output: WiFi connection status, HTTP download progress, bitmap validation, pixel rendering time, display refresh timing
- Verify on device: Check if image appears on e-ink display after upload

### End-to-End
1. Start server: `cargo run -- --serve --port 8080`
2. Upload client to ESP32-S3 with server IP in `config.h`
3. Verify image appears on e-ink display within expected update interval
4. Monitor serial output for any WiFi/HTTP/bitmap errors

## Common Issues & Solutions

### Bitmap Validation Errors
- "Invalid magic number": EPBM header corrupted or wrong file format
- "Dimension mismatch": Bitmap size doesn't match display (must be 800×480)
- Solution: Verify server is generating correct EPBM format

### Memory Allocation
- ESP32-S3 has limited RAM (~300KB free for sketches)
- EPBM bitmap requires exactly 384,008 bytes
- Always free bitmap buffer after rendering: `free(bitmap_buffer)`
- Check for memory fragmentation if allocation fails
